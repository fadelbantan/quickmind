<!DOCTYPE html>
<html>

<head>
  <title>QuickMind</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>

<body>
  <!-- LeaderLine library for drawing connections -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leader-line/1.0.7/leader-line.min.js"></script>

  <div class="node root" data-id="0">
    <div class="content" contenteditable="true">click to edit</div>
    <button class="add-child" title="Add Child">+</button>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      let counter = 0;
      const connectionMap = {}; // Store leader lines for each parent node

      // updates connection lines between a parent and its children
      function updateConnections(parent) {
        const parentId = parent.dataset.id;

        // remove existing lines for this parent if any
        if (connectionMap[parentId]) {
          connectionMap[parentId].forEach(line => line.remove());
        }
        const children = Array.from(document.querySelectorAll(`[data-parent="${parentId}"]`));
        const lines = [];

        children.forEach(child => {
          const line = new LeaderLine(
            LeaderLine.pointAnchor(parent, { x: '50%', y: '50%' }),
            LeaderLine.pointAnchor(child, { x: '50%', y: '50%' }),
            { path: 'grid' }
          );
          lines.push(line);
        });
        connectionMap[parentId] = lines;
      }

      function attachEvents(node) {
        // handle add children nodes
        const childBtn = node.querySelector('.add-child');
        if (childBtn) {
          childBtn.addEventListener('click', () => {
            createNode(node);
            layoutChildren(node);
            updateConnections(node);
          });
        }

        // handle adding sibling nodes
        const siblingBtn = node.querySelector('.add-sibling');
        if (siblingBtn) {
          siblingBtn.addEventListener('click', () => {
            const parentId = node.dataset.parent;
            const parentNode = document.querySelector(`[data-id="${parentId}"]`);
            if (!parentNode) return; // only appears after root
            createNode(parentNode);
            layoutChildren(parentNode);
            updateConnections(parentNode);
          });
        }
      }

      // create a new node under a parent
      function createNode(parentNode) {
        counter += 1;

        const node = document.createElement('div');
        node.className = 'node';
        node.dataset.id = counter;
        node.dataset.parent = parentNode.dataset.id;

        // inner content and buttons
        node.innerHTML = `
          <div class="content" contenteditable="true">new node</div>
          <button class="add-child" title="Add Child">+</button>
          <button class="add-sibling" title="Add Sibling">+</button>
        `;

        document.body.appendChild(node);

        // initial placement close to the parent; will be arranged later
        const refRect = parentNode.getBoundingClientRect();
        node.style.left = refRect.left + 'px';
        node.style.top = refRect.bottom + 100 + 'px';

        attachEvents(node); // logic in the buttons
        return node;
      }

      // arrange children of a parent so they do not overlap
      function layoutChildren(parent) {
        const children = Array.from(document.querySelectorAll(`[data-parent="${parent.dataset.id}"]`));
        if (children.length === 0) return;
        const parentRect = parent.getBoundingClientRect();
        const spacing = 150;
        const startX = parentRect.left - ((children.length - 1) / 2) * spacing;
        const top = parentRect.bottom + 100;
        children.forEach((child, idx) => {
          child.style.left = startX + idx * spacing + 'px';
          child.style.top = top + 'px';
          // update lines for the moved child
          updateConnections(child);
        });
      }


      // Kick things off
      const root = document.querySelector('.root');
      attachEvents(root);
    });
  </script>
</body>

</html>