<head>
  <title>QuickMind</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>

<body>
  <!-- LeaderLine library for drawing connections -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leader-line/1.0.7/leader-line.min.js"></script>

  <div id="canvas">
    <div class="node root" data-id="0" tabindex="0">
      <div class="content" contenteditable="false">click to edit</div>
      <button class="add-child" title="Add Child">+</button>
    </div>
  </div>

  {{ zoom_controls|safe }}

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      let counter = 0;
      const connectionMap = {}; // Store leader lines for each parent node
      const canvas = document.getElementById('canvas');
      const controls = {
        zoomIn: document.getElementById('zoom-in'),
        zoomOut: document.getElementById('zoom-out'),
        zoomDisplay: document.getElementById('zoom-display')
      };

      let selectedNode = null;
      let draggedNode = null;
      let dragStartX = 0;
      let dragStartY = 0;
      let startLeft = 0;
      let startTop = 0;

      function stopDragging() {
        if (draggedNode) {
          const parentId = draggedNode.dataset.parent;
          if (parentId) {
            const parentNode = document.querySelector(`[data-id="${parentId}"]`);
            if (parentNode) updateConnections(parentNode);
          }
          updateConnections(draggedNode);
          draggedNode = null;
        }
        isPanning = false;
        canvas.classList.remove('dragging');
      }

      function selectNode(node) {
        if (selectedNode) selectedNode.classList.remove('selected');
        selectedNode = node;
        if (node) {
          node.classList.add('selected');
          node.focus();
        }
      }

      function startEditing(node) {
        const content = node.querySelector('.content');
        if (!content) return;
        selectNode(node);
        content.contentEditable = 'true';
        content.focus();
        const range = document.createRange();
        range.selectNodeContents(content);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);

        function finish() {
          content.contentEditable = 'false';
          content.removeEventListener('blur', finish);
        }
        content.addEventListener('blur', finish);
        content.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            e.preventDefault();
            content.blur();
          }
        }, { once: true });
      }

      function repositionAllLines() {
        Object.values(connectionMap).flat().forEach(line => line.position());
      }

      function getChildren(node) {
        return Array.from(document.querySelectorAll(`[data-parent="${node.dataset.id}"]`));
      }

      function updateNodeButtons(node) {
        const isRoot = node.classList.contains('root');
        const childBtn = node.querySelector('.add-child');
        const siblingBtn = node.querySelector('.add-sibling');
        const children = getChildren(node);

        if (isRoot) {
          if (siblingBtn) siblingBtn.style.display = 'none';
          if (childBtn) childBtn.style.display = '';
        } else if (children.length === 0) {
          if (childBtn) childBtn.style.display = '';
          if (siblingBtn) siblingBtn.style.display = '';
        } else {
          if (childBtn) childBtn.style.display = 'none';
          if (siblingBtn) siblingBtn.style.display = '';
        }
      }


      function attachEvents(node) {
        // handle add children nodes
        const childBtn = node.querySelector('.add-child');
        if (childBtn) {
          childBtn.addEventListener('click', () => {
            createNode(node);
            layoutChildren(node);
            updateConnections(node);
            updateNodeButtons(node);
          });
        }

        // handle adding sibling nodes
        const siblingBtn = node.querySelector('.add-sibling');
        if (siblingBtn) {
          siblingBtn.addEventListener('click', () => {
            const parentId = node.dataset.parent;
            const parentNode = document.querySelector(`[data-id="${parentId}"]`);
            if (!parentNode) return;
            createNode(parentNode);
            layoutChildren(parentNode);
            updateConnections(parentNode);
            updateNodeButtons(parentNode);
          });
        }

        node.addEventListener('click', e => {
          if (e.target.closest('button')) return;
          selectNode(node);
        });

        node.addEventListener('dblclick', e => {
          if (e.target.closest('button')) return;
          startEditing(node);
        });

        node.addEventListener('keydown', e => {
          if (e.key === 'Enter' && document.activeElement !== node.querySelector('.content')) {
            e.preventDefault();
            startEditing(node);
          }
        });

        node.addEventListener('mousedown', e => {
          if (!node.classList.contains('selected') || e.target.closest('button') || e.target.classList.contains('content')) return;
          draggedNode = node;
          dragStartX = e.clientX;
          dragStartY = e.clientY;
          const style = window.getComputedStyle(node);
          startLeft = parseFloat(style.left);
          startTop = parseFloat(style.top);
        });
      }

      function createNode(parentNode) {
        counter += 1;

        const node = document.createElement('div');
        node.className = 'node';
        node.dataset.id = counter;
        node.dataset.parent = parentNode.dataset.id;

        node.innerHTML = `
          <div class="content" contenteditable="false">new node</div>
          <button class="add-child" title="Add Child">+</button>
          <button class="add-sibling" title="Add Sibling">+</button>
        `;
        node.tabIndex = 0;

        canvas.appendChild(node);

        const refRect = parentNode.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        node.style.left = refRect.right - canvasRect.left + 100 + 'px';
        node.style.top = refRect.top - canvasRect.top + 'px';

        attachEvents(node);
        updateNodeButtons(node);
        return node;
      }

      function layoutChildren(parent) {
        const children = Array.from(document.querySelectorAll(`[data-parent="${parent.dataset.id}"]`));
        if (children.length === 0) return;
        const parentRect = parent.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        const spacing = 120;
        const left = parentRect.right - canvasRect.left + 100;
        const startY = parentRect.top - canvasRect.top - ((children.length - 1) / 2) * spacing;
        children.forEach((child, idx) => {
          child.style.left = left + 'px';
          child.style.top = startY + idx * spacing + 'px';
          updateConnections(child);
        });
      }

      let scale = 1;

      function updateZoomDisplay() {
        controls.zoomDisplay.textContent = Math.round(scale * 100) + '%';
      }

      function applyTransform() {
        canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        repositionAllLines();
        updateZoomDisplay();
      }

      // updates connection lines between a parent and its children
      function updateConnections(parent) {
        const parentId = parent.dataset.id;

        // remove existing lines for this parent if any
        if (connectionMap[parentId]) {
          connectionMap[parentId].forEach(line => line.remove());
        }
        const children = Array.from(document.querySelectorAll(`[data-parent="${parentId}"]`));
        const lines = [];

        children.forEach(child => {
          const line = new LeaderLine(
            parent,
            child,
            {
              startSocket: 'right',
              endSocket: 'left',
              path: 'fluid',
              startPlug: 'behind',
              endPlug: 'behind'
            }
          );
          lines.push(line);
        });
        connectionMap[parentId] = lines;
      }

      let isPanning = false;
      let panX = 0;
      let panY = 0;
      let startX = 0;
      let startY = 0;

      canvas.addEventListener('mousedown', e => {
        if (e.target.closest('.node')) return;
        isPanning = true;
        startX = e.clientX - panX;
        startY = e.clientY - panY;
        canvas.classList.add('dragging');
      });

      canvas.addEventListener('touchstart', e => {
        if (e.touches.length !== 1 || e.target.closest('.node')) return;
        isPanning = true;
        startX = e.touches[0].clientX - panX;
        startY = e.touches[0].clientY - panY;
      });

      document.addEventListener('mousemove', e => {
        if (draggedNode) {
          const dx = (e.clientX - dragStartX) / scale;
          const dy = (e.clientY - dragStartY) / scale;
          draggedNode.style.left = startLeft + dx + 'px';
          draggedNode.style.top = startTop + dy + 'px';
          repositionAllLines();
        } else if (isPanning) {
          panX = e.clientX - startX;
          panY = e.clientY - startY;
          applyTransform();
        }
      });

      document.addEventListener('touchmove', e => {
        if (draggedNode && e.touches.length === 1) {
          const dx = (e.touches[0].clientX - dragStartX) / scale;
          const dy = (e.touches[0].clientY - dragStartY) / scale;
          draggedNode.style.left = startLeft + dx + 'px';
          draggedNode.style.top = startTop + dy + 'px';
          repositionAllLines();
        } else if (isPanning && e.touches.length === 1) {
          panX = e.touches[0].clientX - startX;
          panY = e.touches[0].clientY - startY;
          applyTransform();
        }
      });

      document.addEventListener('mouseup', stopDragging);
      document.addEventListener('touchend', stopDragging);
      document.addEventListener('mouseleave', stopDragging);
      document.addEventListener('touchcancel', stopDragging);

      canvas.addEventListener('wheel', e => {
        e.preventDefault();
        if (e.ctrlKey) {
          // Pinch to zoom
          if (e.deltaY < 0) {
            scale += 0.1;
          } else {
            scale -= 0.1;
          }
          scale = Math.min(Math.max(0.1, scale), 3);
        } else {
          // two finger drag to pan
          panX -= e.deltaX;
          panY -= e.deltaY;
        }
        applyTransform();
      });

      controls.zoomIn.addEventListener('click', () => {
        scale = Math.min(scale + 0.1, 3);
        applyTransform();
      });

      controls.zoomOut.addEventListener('click', () => {
        scale = Math.max(scale - 0.1, 0.1);
        applyTransform();
      });

      // Kick things off
      const root = document.querySelector('.root');
      attachEvents(root);
      applyTransform();
      updateNodeButtons(root);
    });
  </script>
</body>

</html>