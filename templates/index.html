<!DOCTYPE html>
<html>

<head>
  <title>QuickMind</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>

<body>
  <!-- LeaderLine library for drawing connections -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leader-line/1.0.7/leader-line.min.js"></script>

  <div id="canvas">
    <div class="node root" data-id="0">
      <div class="content" contenteditable="true">click to edit</div>
      <button class="add-child" title="Add Child">+</button>
    </div>
  </div>

  <script>
      document.addEventListener('DOMContentLoaded', () => {
        let counter = 0;
        const connectionMap = {}; // Store leader lines for each parent node
        const canvas = document.getElementById('canvas');

      // updates connection lines between a parent and its children
      function updateConnections(parent) {
        const parentId = parent.dataset.id;

        // remove existing lines for this parent if any
        if (connectionMap[parentId]) {
          connectionMap[parentId].forEach(line => line.remove());
        }
        const children = Array.from(document.querySelectorAll(`[data-parent="${parentId}"]`));
        const lines = [];

        children.forEach(child => {
          const line = new LeaderLine(
            parent,
            child,
            {
              startSocket: 'right',
              endSocket: 'left',
              path: 'fluid',
              startPlug: 'behind',
              endPlug: 'behind'
            }
          );
          lines.push(line);
        });
        connectionMap[parentId] = lines;
      }

      function repositionAllLines() {
        Object.values(connectionMap).flat().forEach(line => line.position());
      }

      function attachEvents(node) {
        // handle add children nodes
        const childBtn = node.querySelector('.add-child');
        if (childBtn) {
          childBtn.addEventListener('click', () => {
            createNode(node);
            layoutChildren(node);
            updateConnections(node);
          });
        }

        // handle adding sibling nodes
        const siblingBtn = node.querySelector('.add-sibling');
        if (siblingBtn) {
          siblingBtn.addEventListener('click', () => {
            const parentId = node.dataset.parent;
            const parentNode = document.querySelector(`[data-id="${parentId}"]`);
            if (!parentNode) return; // only appears after root
            createNode(parentNode);
            layoutChildren(parentNode);
            updateConnections(parentNode);
          });
        }
      }

      // create a new node under a parent
      function createNode(parentNode) {
        counter += 1;

        const node = document.createElement('div');
        node.className = 'node';
        node.dataset.id = counter;
        node.dataset.parent = parentNode.dataset.id;

        // inner content and buttons
        node.innerHTML = `
          <div class="content" contenteditable="true">new node</div>
          <button class="add-child" title="Add Child">+</button>
          <button class="add-sibling" title="Add Sibling">+</button>
        `;

        canvas.appendChild(node);

        // initial placement close to the parent; will be arranged later
        const refRect = parentNode.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        node.style.left = refRect.right - canvasRect.left + 100 + 'px';
        node.style.top = refRect.top - canvasRect.top + 'px';

        attachEvents(node); // logic in the buttons
        return node;
      }

      // arrange children of a parent so they do not overlap
      function layoutChildren(parent) {
        const children = Array.from(document.querySelectorAll(`[data-parent="${parent.dataset.id}"]`));
        if (children.length === 0) return;
        const parentRect = parent.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        const spacing = 120;
        const left = parentRect.right - canvasRect.left + 100;
        const startY = parentRect.top - canvasRect.top - ((children.length - 1) / 2) * spacing;
        children.forEach((child, idx) => {
          child.style.left = left + 'px';
          child.style.top = startY + idx * spacing + 'px';
          // update lines for the moved child
          updateConnections(child);
        });
      }

      let isPanning = false;
      let panX = 0;
      let panY = 0;
      let startX = 0;
      let startY = 0;

      canvas.addEventListener('mousedown', e => {
        if (e.target.closest('.node')) return;
        isPanning = true;
        startX = e.clientX - panX;
        startY = e.clientY - panY;
        canvas.classList.add('dragging');
      });

      document.addEventListener('mousemove', e => {
        if (!isPanning) return;
        panX = e.clientX - startX;
        panY = e.clientY - startY;
        canvas.style.transform = `translate(${panX}px, ${panY}px)`;
        repositionAllLines();
      });

      document.addEventListener('mouseup', () => {
        isPanning = false;
        canvas.classList.remove('dragging');
      });


      // Kick things off
      const root = document.querySelector('.root');
      attachEvents(root);
    });
  </script>
</body>

</html>