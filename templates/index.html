<head>
  <title>QuickMind</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>

<body>
  <!-- LeaderLine library for drawing connections -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leader-line/1.0.7/leader-line.min.js"></script>

  <div id="canvas">
    <div class="node root" data-id="0">
      <div class="content" contenteditable="true">click to edit</div>
      <button class="add-child" title="Add Child">+</button>
    </div>
  </div>

  {{ zoom_controls|safe }}

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      let counter = 0;
      const connectionMap = {}; // Store leader lines for each parent node
      const canvas = document.getElementById('canvas');
      const controls = {
        zoomIn: document.getElementById('zoom-in'),
        zoomOut: document.getElementById('zoom-out'),
        zoomDisplay: document.getElementById('zoom-display')
      };

      function repositionAllLines() {
        Object.values(connectionMap).flat().forEach(line => line.position());
      }

      function attachEvents(node) {
        // handle add children nodes
        const childBtn = node.querySelector('.add-child');
        if (childBtn) {
          childBtn.addEventListener('click', () => {
            createNode(node);
            layoutChildren(node);
            updateConnections(node);
          });
        }

        // handle adding sibling nodes
        const siblingBtn = node.querySelector('.add-sibling');
        if (siblingBtn) {
          siblingBtn.addEventListener('click', () => {
            const parentId = node.dataset.parent;
            const parentNode = document.querySelector(`[data-id="${parentId}"]`);
            if (!parentNode) return;
            createNode(parentNode);
            layoutChildren(parentNode);
            updateConnections(parentNode);
          });
        }
      }

      function createNode(parentNode) {
        counter += 1;

        const node = document.createElement('div');
        node.className = 'node';
        node.dataset.id = counter;
        node.dataset.parent = parentNode.dataset.id;

        node.innerHTML = `
          <div class="content" contenteditable="true">new node</div>
          <button class="add-child" title="Add Child">+</button>
          <button class="add-sibling" title="Add Sibling">+</button>
        `;

        canvas.appendChild(node);

        const refRect = parentNode.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        node.style.left = refRect.right - canvasRect.left + 100 + 'px';
        node.style.top = refRect.top - canvasRect.top + 'px';

        attachEvents(node);
        return node;
      }

      function layoutChildren(parent) {
        const children = Array.from(document.querySelectorAll(`[data-parent="${parent.dataset.id}"]`));
        if (children.length === 0) return;
        const parentRect = parent.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        const spacing = 120;
        const left = parentRect.right - canvasRect.left + 100;
        const startY = parentRect.top - canvasRect.top - ((children.length - 1) / 2) * spacing;
        children.forEach((child, idx) => {
          child.style.left = left + 'px';
          child.style.top = startY + idx * spacing + 'px';
          updateConnections(child);
        });
      }

      let scale = 1;

      function updateZoomDisplay() {
        controls.zoomDisplay.textContent = Math.round(scale * 100) + '%';
      }

      function applyTransform() {
        canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        repositionAllLines();
        updateZoomDisplay();
      }

      // updates connection lines between a parent and its children
      function updateConnections(parent) {
        const parentId = parent.dataset.id;

        // remove existing lines for this parent if any
        if (connectionMap[parentId]) {
          connectionMap[parentId].forEach(line => line.remove());
        }
        const children = Array.from(document.querySelectorAll(`[data-parent="${parentId}"]`));
        const lines = [];

        children.forEach(child => {
          const line = new LeaderLine(
            parent,
            child,
            {
              startSocket: 'right',
              endSocket: 'left',
              path: 'fluid',
              startPlug: 'behind',
              endPlug: 'behind'
            }
          );
          lines.push(line);
        });
        connectionMap[parentId] = lines;
      }

      let isPanning = false;
      let panX = 0;
      let panY = 0;
      let startX = 0;
      let startY = 0;

      canvas.addEventListener('mousedown', e => {
        if (e.target.closest('.node')) return;
        isPanning = true;
        startX = e.clientX - panX;
        startY = e.clientY - panY;
        canvas.classList.add('dragging');
      });

      canvas.addEventListener('touchstart', e => {
        if (e.touches.length !== 1 || e.target.closest('.node')) return;
        isPanning = true;
        startX = e.touches[0].clientX - panX;
        startY = e.touches[0].clientY - panY;
      });

      document.addEventListener('mousemove', e => {
        if (!isPanning) return;
        panX = e.clientX - startX;
        panY = e.clientY - startY;
        applyTransform();
      });

      document.addEventListener('touchmove', e => {
        if (!isPanning || e.touches.length !== 1) return;
        panX = e.touches[0].clientX - startX;
        panY = e.touches[0].clientY - startY;
        applyTransform();
      });

      document.addEventListener('mouseup', () => {
        isPanning = false;
        canvas.classList.remove('dragging');
      });

      document.addEventListener('touchend', () => {
        isPanning = false;
      });

      canvas.addEventListener('wheel', e => {
        e.preventDefault();
        if (e.ctrlKey) {
          // Pinch to zoom
          if (e.deltaY < 0) {
            scale += 0.1;
          } else {
            scale -= 0.1;
          }
          scale = Math.min(Math.max(0.1, scale), 3);
        } else {
          // two finger drag to pan
          panX -= e.deltaX;
          panY -= e.deltaY;
        }
        applyTransform();
      });

      controls.zoomIn.addEventListener('click', () => {
        scale = Math.min(scale + 0.1, 3);
        applyTransform();
      });

      controls.zoomOut.addEventListener('click', () => {
        scale = Math.max(scale - 0.1, 0.1);
        applyTransform();
      });

      // Kick things off
      const root = document.querySelector('.root');
      attachEvents(root);
      applyTransform();
    });
  </script>
</body>

</html>