<!DOCTYPE html>
<html>

<head>
  <title>QuickMind</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>

<body>
  <!-- LeaderLine library for drawing connections -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leader-line/1.0.7/leader-line.min.js"></script>

  <div id="canvas">
    <div class="node root" data-id="0">
      <div class="content" contenteditable="true">click to edit</div>
      <button class="add-child" title="Add Child">+</button>
    </div>
  </div>

  {{ zoom_controls|safe }}

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      let counter = 0;
      const connectionMap = {}; // Store leader lines for each parent node
      const canvas = document.getElementById('canvas');
      const controls = {
        zoomIn: document.getElementById('zoom-in'),
        zoomOut: document.getElementById('zoom-out')
      };

      let scale = 1;

      function applyTransform() {
        canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        repositionAllLines();
      }

      // updates connection lines between a parent and its children
      function updateConnections(parent) {
        const parentId = parent.dataset.id;

        // remove existing lines for this parent if any
        if (connectionMap[parentId]) {
          connectionMap[parentId].forEach(line => line.remove());
        }
        const children = Array.from(document.querySelectorAll(`[data-parent="${parentId}"]`));
        const lines = [];

        children.forEach(child => {
          const line = new LeaderLine(
            parent,
            child,
            {
              startSocket: 'right',
              endSocket: 'left',
              path: 'fluid',
              startPlug: 'behind',
              endPlug: 'behind'
            }
          );
          lines.push(line);

          child.style.left = left + 'px';
          child.style.top = startY + idx * spacing + 'px';
          // update lines for the moved child
          updateConnections(child);
        });
      }

      let isPanning = false;
      let panX = 0;
      let panY = 0;
      let startX = 0;
      let startY = 0;

      canvas.addEventListener('mousedown', e => {
        if (e.target.closest('.node')) return;
        isPanning = true;
        startX = e.clientX - panX;
        startY = e.clientY - panY;
        canvas.classList.add('dragging');
      });

      document.addEventListener('mousemove', e => {
        if (!isPanning) return;
        panX = e.clientX - startX;
        panY = e.clientY - startY;
        applyTransform();
      });

      document.addEventListener('mouseup', () => {
        isPanning = false;
        canvas.classList.remove('dragging');
      });

      canvas.addEventListener('wheel', e => {
        e.preventDefault();
        if (e.deltaY < 0) {
          scale += 0.1;
        } else {
          scale -= 0.1;
        }
        scale = Math.min(Math.max(0.1, scale), 3);
        applyTransform();
      });

      controls.zoomIn.addEventListener('click', () => {
        scale = Math.min(scale + 0.1, 3);
        applyTransform();
      });

      controls.zoomOut.addEventListener('click', () => {
        scale = Math.max(scale - 0.1, 0.1);
        applyTransform();
      });

      // Kick things off
      const root = document.querySelector('.root');
      attachEvents(root);
      applyTransform();
    });
  </script>
</body>

</html>